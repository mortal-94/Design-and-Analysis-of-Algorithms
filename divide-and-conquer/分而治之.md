# 分而治之

## 归并排序

子问题：对部分数组排序。子问题会一直划分到数组长度为1。

自底向上合并子问题：合并两个有序数组。

对数组 A[n] 进行归并排序算法（递归）：

1. 分解成两个子问题：对A的左半部分进行归并排序；对A的右半部分进行归并排序。

2. 合并：讲左右两部分有序的数组合并成整体有序。

分解子问题会把数组树状分成 log n 层，以每层的角度看合并操作——O(n)。

故时间复杂度—— O(n log n)

[merge_sort.cpp](./code/merge_sort.cpp)

## 快速排序

### 划分

选取A的某个元素做基准值，排好并返回它的位置的同时，将小于和大于它的分别放两边。

划分算法流程：

1. 选取最后一个元素做基准值pivot
2. 采用双指针i，j；i 定义为：i 及 i 的左边都为小于或等于pivot的数，初始化为左边界外一位。
3. 用j遍历数组，发现小于或等于pivot的都把它们换到 i 的前面；更新 i（多了一个小于或等于pivot的数）
4. 至此，i 满足：i 及 i 的左边都为小于或等于pivot的数，i 的右边都大于 pivot。返回 i

划分算法时间复杂度易知为 O(n)

### 算法设计

子问题：对数组 *划分* 的两部分进行排序。

快排流程（递归）：

1. 判断数组长度是否大于1
2. 是，对数组进行划分，对划分好的左右两个区域继续快排
3. 否，结束

### 分析与改进

最坏情况：每次划分后基准值都在最右边（上面选的是最后一个元素做基准值），即没有起到划分的作用，从子问题树的角度看，它是一棵 n 层的树，从根到 n层叶子每层的需划分的数组长度为 n, n-1, ..., 1 。故时间复杂度为—— $O(n^2)$ 

最好情况：每次划分后基准值都在中间，子问题树是一棵 log n 层的树，每层的需要的复杂度为 O(n) 。故时间复杂度为—— $O(n\log n)$ 

改进：在划分算法之前，随机选取一个元素与数组的最后一个元素进行交换（上面选的是最后一个元素做基准值）。（这也是一种舍伍德随机算法的思想）

[quick_sort](code/quick_sort.cpp)

## 次序选择

### 问题描述

给定一个数组 A，和小于数组长度的正整数 k，返回 A 第 k 小的元素。

### 算法设计



## 最大子数组

## 逆序对统计

